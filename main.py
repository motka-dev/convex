import tkinter as tkfrom typing import Tuple, Listimport mathclass Point:    x: int    y: int    def __init__(self, x: int, y: int) -> None:        self.x = x        self.y = y    def __repr__(self):        return f'(X: {self.x}; Y: {self.y})'    def __eq__(self, other):        if self.x == other.x and self.y == other.y:            return True        else:            return False    def __set__(self, instance, value):        self.x = value.x        self.y = value.yclass Application(tk.Frame):    width: int = 600    height: int = 600    _canvas: tk.Canvas = None    _points: List[Point] = list()    _widgets: List = list()    def __init__(self, master=None):        super().__init__(master)        self.master = master        self.pack()        self.create_canvas()        self.create_widgets()        self.bind_events()    def create_canvas(self) -> None:        self._canvas: tk.Canvas = tk.Canvas(self, width=self.width, height=self.height, bg='white')        self._canvas.pack()    def create_widgets(self) -> None:        button = tk.Button(text="Разделить и властвовать", command=self.start).pack()        self._widgets.append(button)    def pack_the_point(self, x: int, y: int) -> None:        self._canvas.create_rectangle(x, y, x + 3, y + 3)        self._points.append(Point(x, y))    @staticmethod    def split_list(points: List, parts: int = 2) -> List[List[Point]]:        part_len = math.ceil(len(points) / parts)        # Сортировка список точек        sorted_list = sorted(points, key=lambda p1: p1.x)        return [sorted_list[part_len * k:part_len * (k + 1)] for k in range(parts)]    # События    def bind_events(self):        # Нажатие лев. кнопки мыши        self._canvas.bind("<Button-1>", lambda event: self.pack_the_point(event.x, event.y))    # Старт алгоритма    def start(self):        convex = self.get_convex(self._points)        for point in convex:            self._canvas.create_rectangle(point.x, point.y, point.x + 3, point.y + 3, fill="red")    @staticmethod    def get_rightest_point(points: List[Point]):        points.sort(key=lambda p: p.x)        return points[-1], len(points) - 1    @staticmethod    def get_leftest_point(points: List[Point]):        points.sort(key=lambda p: p.x)        return points[0], 0    @staticmethod    def rotate(point_1: Point, point_2: Point, point_3: Point):        return (point_2.x-point_1.x)*(point_3.y-point_2.y)-(point_2.y-point_1.y)*(point_3.x-point_2.x)    def merge_convex(self, l_convex: List[Point], r_convex: List[Point]):        rpoint_of_left_convex, rpoint_index = Application.get_rightest_point(l_convex)        lpoint_of_right_convex, lpoint_index = Application.get_leftest_point(r_convex)        result_convex: List[Point] = list()        print(l_convex, r_convex)        return result_convex    # рекурентная функция    def get_convex(self, points: List[Point]) -> List[Point]:        if len(points) <= 2:            return sorted(points, key=lambda p: p.x)        left_points, right_points = Application.split_list(points)        convex = self.merge_convex(self.get_convex(left_points), self.get_convex(right_points))        return convex        #print(*Application.split_list(points))root = tk.Tk()app = Application(master=root)app.mainloop()